#!/usr/bin/env python3
"""Prototype generator for lookup tables.

Reads a CSV of `codepoint_hex,replacement` lines and generates a Gleam
module that exposes a `translit_lookup(codepoint: Int) -> Option(String)`.

This is a prototype: later versions will generate compact BitArray literals
and a two-level index like string-width.

Usage:
  ./scripts/generate_bitarray_tables.py --input data/translit.csv --out src/str/internal/generated_translit_table.gleam --module str/internal/generated_translit_table --name translit_map

If no input is provided the script emits a small sample mapping.
"""
import argparse
import csv
import sys

SAMPLE = [
    (0x00C0, "A"),  # À
    (0x00C1, "A"),  # Á
    (0x00E0, "a"),  # à
    (0x00E9, "e"),  # é
]

TEMPLATE = """// Generated by scripts/generate_bitarray_tables.py
// Module: __MODULE__

import gleam/dict
import gleam/string

pub const __NAME__pairs: List(#(Int, String)) = [
__PAIRS__
]

pub fn __NAME__lookup(cp: Int) -> Result(String, Nil) {
  let d = dict.from_list(__NAME__pairs)
  case dict.get(d, cp) {
    Ok(v) -> Ok(v)
    Error(_) -> Error(Nil)
  }
}

pub fn __NAME__lookup_by_grapheme(s: String) -> Result(String, Nil) {
  case string.to_utf_codepoints(s) {
    [cp] -> __NAME__lookup(string.utf_codepoint_to_int(cp))
    _ -> Error(Nil)
  }
}
"""


def read_csv(path):
    pairs = []
    with open(path, newline="") as f:
        r = csv.reader(f)
        for row in r:
            if not row:
                continue
            h = row[0].strip()
            val = row[1].strip() if len(row) > 1 else ""
            try:
                cp = int(h, 16) if h.startswith("0x") or h.startswith("0X") else int(h, 16)
            except Exception:
                # try parse as hex without prefix
                cp = int(h, 16)
            pairs.append((cp, val))
    return pairs


def format_pairs(pairs):
    lines = []
    for cp, val in pairs:
        lines.append(f"  #({hex(cp)}, \"{val}\"),")
    return "\n".join(lines)


def build_pages(pairs, page_size=256, word_bits=64):
    # pairs: list of (cp int, replacement str)
    # Build per-page bit-index and a deduplicated global pool of strings.
    # We emit per-page masks (packed words) and a flat index list that points
    # into `pool_strings` (the deduplicated list). This avoids repeating
    # identical replacement strings in the generated module.
    pages = {}
    page_map = {}

    for cp, val in pairs:
        page = cp // page_size
        idx = cp % page_size
        if page not in pages:
            pages[page] = set()
            page_map[page] = []
        pages[page].add(idx)
        page_map[page].append((idx, val))

    # build deduplicated pool and per-page flat indices
    sorted_pages = sorted(pages.keys())
    offsets = {}
    pool_strings = []  # unique strings
    pool_index_map = {}  # val -> pool_strings index
    masks = {}
    flat_indices = []  # flattened per-page pool index list

    for p in sorted_pages:
        offsets[p] = len(flat_indices)
        # order entries by idx
        entries = sorted(page_map[p], key=lambda x: x[0])
        for idx, val in entries:
            if val in pool_index_map:
                pi = pool_index_map[val]
            else:
                pi = len(pool_strings)
                pool_index_map[val] = pi
                pool_strings.append(val)
            flat_indices.append(pi)

        # build compact mask words for this page
        indices = sorted(list(pages[p]))
        words = []
        for base in range(0, page_size, word_bits):
            w = 0
            for i in indices:
                if base <= i < base + word_bits:
                    w |= (1 << (i - base))
            words.append(w)
        masks[p] = words

    return masks, offsets, pool_strings, flat_indices


def render_pages_module(pairs, module, name, page_size=256, word_bits=64):
    masks, offsets, pool_strings, flat_indices = build_pages(pairs, page_size, word_bits)
    max_page = max(masks.keys()) if masks else 0

    # render page offsets array of length max_page+1, -1 for empty
    page_offsets = [ -1 ] * (max_page + 1)
    page_masks = []
    words_per_page = (page_size + word_bits - 1) // word_bits
    for p in range(max_page + 1):
        if p in masks:
            page_offsets[p] = offsets[p]
            page_masks.append(masks[p])
        else:
            page_masks.append([0]*words_per_page)

    # format as Gleam literals
    offsets_str = ', '.join(str(x) for x in page_offsets)

    masks_str = []
    for m in page_masks:
        masks_str.append('[{}]'.format(', '.join('0x{:x}'.format(b) for b in m)))
    masks_literal = ',\n  '.join(masks_str)

    pool_strings_str = ',\n  '.join(f'"{s}"' for s in pool_strings)
    flat_indices_str = ',\n  '.join(str(i) for i in flat_indices)

    mod = """// Generated by scripts/generate_bitarray_tables.py
// Module: __MODULE__

import gleam/string

pub const __NAME__page_offsets: List(Int) = [ __OFFSETS__ ]

// Masks: each page is a list of `word_bits`-width integer words representing
// which codepoints within the page have replacements.
pub const __NAME__page_masks: List(List(Int)) = [
  __MASKS__
]

// Deduplicated pool of replacement strings
pub const __NAME__pool_strings: List(String) = [
  __POOL_STRINGS__
]

// Flat per-page indices into `pool_strings`; page offsets index into this list
pub const __NAME__page_index_flat: List(Int) = [
  __FLAT_INDICES__
]

import str/internal/bitarray_helpers as bits

pub fn __NAME__lookup_by_codepoint(cp: Int) -> Result(String, Nil) {
  let page = cp / __PAGE_SIZE__
  case bits.get_at(__NAME__page_offsets, page) {
    Ok(offset) ->
      case offset == -1 {
        True -> Error(Nil)
        False -> {
          let idx = cp % __PAGE_SIZE__
          let page_masks = case bits.get_at(__NAME__page_masks, page) { Ok(m) -> m Error(_) -> [] }
          let word_idx = idx / __WORD_BITS__
          let word = case bits.get_at(page_masks, word_idx) { Ok(w) -> w Error(_) -> 0 }
          let bit = bits.bit_in_word(word, idx % __WORD_BITS__)
          case bit == 0 {
            True -> Error(Nil)
            False -> {
              let rank = bits.rank_in_masks(page_masks, idx, __WORD_BITS__)
              let pool_idx = case bits.get_at(__NAME__page_index_flat, offset + rank) { Ok(v) -> v Error(_) -> -1 }
              case pool_idx == -1 {
                True -> Error(Nil)
                False -> {
                  let val = case bits.get_at(__NAME__pool_strings, pool_idx) { Ok(v) -> v Error(_) -> "" }
                  Ok(val)
                }
              }
            }
          }
        }
      }
    Error(_) -> Error(Nil)
  }
}"""
    mod = mod.replace('__MODULE__', module)
    mod = mod.replace('__NAME__', name + '_')
    mod = mod.replace('__OFFSETS__', offsets_str)
    mod = mod.replace('__MASKS__', masks_literal)
    mod = mod.replace('__POOL_STRINGS__', pool_strings_str)
    mod = mod.replace('__FLAT_INDICES__', flat_indices_str)
    mod = mod.replace('__PAGE_SIZE__', str(page_size))
    mod = mod.replace('__WORD_BITS__', str(word_bits))

    # Add a small helper to look up a single-codepoint grapheme
    grapheme_fn = """

pub fn __NAME__lookup_by_grapheme(s: String) -> Result(String, Nil) {
  case string.to_utf_codepoints(s) {
    [cp] -> __NAME__lookup_by_codepoint(string.utf_codepoint_to_int(cp))
    _ -> Error(Nil)
  }
}
"""
    grapheme_fn = grapheme_fn.replace('__NAME__', name + '_')
    mod = mod + grapheme_fn
    return mod


def main():
    p = argparse.ArgumentParser()
    p.add_argument("--input", help="Input file with pairs (Gleam generated or CSV)")
    p.add_argument("--out", help="Output Gleam file path (defaults to stdout)")
    p.add_argument("--module", help="Gleam module name (for comments)")
    p.add_argument("--name", help="Base name for generated constants", default="translit_map")
    p.add_argument("--mode", help="Mode: table (default) or pages", default="table")
    p.add_argument("--word-bits", help="Width of mask words (default 64)", type=int, default=64)
    args = p.parse_args()

    # Read pairs from existing generated_translit_pairs.gleam or CSV
    if args.input and args.input.endswith('.csv'):
        pairs = read_csv(args.input)
    else:
        # Try to read from Gleam generated pairs module
        path = args.input or 'src/str/internal/generated_translit_pairs.gleam'
        pairs = []
        import re
        with open(path, 'r') as f:
            for line in f:
                m = re.match(r"\s*#\(\"(.*)\",\s*\"(.*)\"\),", line)
                if m:
                    left = m.group(1)
                    right = m.group(2)
                    # get codepoint of first char if single-codepoint
                    if len(left) == 1:
                        cp = ord(left)
                        pairs.append((cp, right))

    module = args.module or "generated_translit_table"
    if args.mode == 'pages':
        out = render_pages_module(pairs, module, args.name, page_size=256, word_bits=args.word_bits)
    else:
        pairs_str = format_pairs(pairs)
        out = TEMPLATE.replace('__MODULE__', module).replace('__PAIRS__', pairs_str).replace('__NAME__', args.name + '_')

    if args.out:
        with open(args.out, "w") as f:
            f.write(out)
        print(f"Wrote {args.out}")
    else:
        print(out)


if __name__ == "__main__":
    main()
