#!/usr/bin/env python3
"""Prototype generator for lookup tables.

Reads a CSV of `codepoint_hex,replacement` lines and generates a Gleam
module that exposes a `translit_lookup(codepoint: Int) -> Option(String)`.

This is a prototype: later versions will generate compact BitArray literals
and a two-level index like string-width.

Usage:
  ./scripts/generate_bitarray_tables.py --input data/translit.csv --out src/str/internal/generated_translit_table.gleam --module str/internal/generated_translit_table --name translit_map

If no input is provided the script emits a small sample mapping.
"""
import argparse
import csv
import sys

SAMPLE = [
    (0x00C0, "A"),  # À
    (0x00C1, "A"),  # Á
    (0x00E0, "a"),  # à
    (0x00E9, "e"),  # é
]

TEMPLATE = """// Generated by scripts/generate_bitarray_tables.py
// Module: {module}

import gleam/dict

pub const {name}_pairs: List(#(Int, String)) = [
{pairs}
]

pub fn {name}_lookup(cp: Int) -> Result(String, Nil) {{
  let d = dict.from_list({name}_pairs)
  case dict.get(d, cp) {{
    Ok(v) -> Ok(v)
    Error(_) -> Error(Nil)
  }}
}}
"""


def read_csv(path):
    pairs = []
    with open(path, newline="") as f:
        r = csv.reader(f)
        for row in r:
            if not row:
                continue
            h = row[0].strip()
            val = row[1].strip() if len(row) > 1 else ""
            try:
                cp = int(h, 16) if h.startswith("0x") or h.startswith("0X") else int(h, 16)
            except Exception:
                # try parse as hex without prefix
                cp = int(h, 16)
            pairs.append((cp, val))
    return pairs


def format_pairs(pairs):
    lines = []
    for cp, val in pairs:
        lines.append(f"  #({hex(cp)}, \"{val}\"),")
    return "\n".join(lines)


def build_pages(pairs, page_size=256):
    # pairs: list of (cp int, replacement str)
    pages = {}
    data = []
    page_map = {}

    for cp, val in pairs:
        page = cp // page_size
        idx = cp % page_size
        if page not in pages:
            pages[page] = [0] * page_size
            page_map[page] = []
        pages[page][idx] = 1
        page_map[page].append((idx, val))

    # build data pool and offsets
    sorted_pages = sorted(pages.keys())
    offsets = {}
    pool = []
    for p in sorted_pages:
        offsets[p] = len(pool)
        # order entries by idx
        for idx, val in sorted(page_map[p], key=lambda x: x[0]):
            pool.append(val)

    return pages, offsets, pool


def render_pages_module(pairs, module, name, page_size=256):
    pages, offsets, pool = build_pages(pairs, page_size)
    max_page = max(pages.keys()) if pages else 0

    # render page offsets array of length max_page+1, -1 for empty
    page_offsets = [ -1 ] * (max_page + 1)
    page_bitlists = []
    for p in range(max_page + 1):
        if p in pages:
            page_offsets[p] = offsets[p]
            page_bitlists.append(pages[p])
        else:
            page_bitlists.append([0]*page_size)

    # format as Gleam literals
    offsets_str = ', '.join(str(x) for x in page_offsets)

    bitlists_str = []
    for bl in page_bitlists:
        bitlists_str.append('[{}]'.format(', '.join(str(b) for b in bl)))
    bitlists_literal = ',\n  '.join(bitlists_str)

    pool_str = ',\n  '.join(f'\"{s}\"' for s in pool)

    mod = """// Generated by scripts/generate_bitarray_tables.py
// Module: __MODULE__

import gleam/list
import gleam/string

pub const __NAME__page_offsets: List(Int) = [ __OFFSETS__ ]

pub const __NAME__page_bitlists: List(List(Int)) = [
  __BITLIST__
]

pub const __NAME__data_pool: List(String) = [
  __POOL__
]

fn get_at(xs: List(a), idx: Int) -> Result(a, Nil) {
  case list.drop(xs, idx) {
    [h, ..] -> Ok(h)
    _ -> Error(Nil)
  }
}

pub fn __NAME__lookup_by_codepoint(cp: Int) -> Result(String, Nil) {
  let page = cp / __PAGE_SIZE__
  case get_at(__NAME__page_offsets, page) {
    Ok(offset) ->
      case offset == -1 {
        True -> Error(Nil)
        False -> {
          let idx = cp % __PAGE_SIZE__
          let page_bits = case get_at(__NAME__page_bitlists, page) { Ok(b) -> b Error(_) -> [] }
          let bit = case get_at(page_bits, idx) { Ok(v) -> v Error(_) -> 0 }
          case bit == 0 {
            True -> Error(Nil)
            False -> {
              let mask = list.take(page_bits, idx)
              let rank = list.fold(mask, 0, fn(acc, b) { acc + b })
              let val = case get_at(__NAME__data_pool, offset + rank) { Ok(v) -> v Error(_) -> "" }
              Ok(val)
            }
          }
        }
      }
    Error(_) -> Error(Nil)
  }
}"""
    mod = mod.replace('__MODULE__', module)
    mod = mod.replace('__NAME__', name + '_')
    mod = mod.replace('__OFFSETS__', offsets_str)
    mod = mod.replace('__BITLIST__', bitlists_literal)
    mod = mod.replace('__POOL__', pool_str)
    mod = mod.replace('__PAGE_SIZE__', str(page_size))

    # Add a small helper to look up a single-codepoint grapheme
    grapheme_fn = """

pub fn __NAME__lookup_by_grapheme(s: String) -> Result(String, Nil) {
  case string.to_utf_codepoints(s) {
    [cp] -> __NAME__lookup_by_codepoint(string.utf_codepoint_to_int(cp))
    _ -> Error(Nil)
  }
}
"""
    grapheme_fn = grapheme_fn.replace('__NAME__', name + '_')
    mod = mod + grapheme_fn
    return mod


def main():
    p = argparse.ArgumentParser()
    p.add_argument("--input", help="Input file with pairs (Gleam generated or CSV)")
    p.add_argument("--out", help="Output Gleam file path (defaults to stdout)")
    p.add_argument("--module", help="Gleam module name (for comments)")
    p.add_argument("--name", help="Base name for generated constants", default="translit_map")
    p.add_argument("--mode", help="Mode: table (default) or pages", default="table")
    args = p.parse_args()

    # Read pairs from existing generated_translit_pairs.gleam or CSV
    if args.input and args.input.endswith('.csv'):
        pairs = read_csv(args.input)
    else:
        # Try to read from Gleam generated pairs module
        path = args.input or 'src/str/internal/generated_translit_pairs.gleam'
        pairs = []
        import re
        with open(path, 'r') as f:
            for line in f:
                m = re.match(r"\s*#\(\"(.*)\",\s*\"(.*)\"\),", line)
                if m:
                    left = m.group(1)
                    right = m.group(2)
                    # get codepoint of first char if single-codepoint
                    if len(left) == 1:
                        cp = ord(left)
                        pairs.append((cp, right))

    module = args.module or "generated_translit_table"
    if args.mode == 'pages':
        out = render_pages_module(pairs, module, args.name)
    else:
        pairs_str = format_pairs(pairs)
        out = TEMPLATE.format(module=module, name=args.name, pairs=pairs_str)

    if args.out:
        with open(args.out, "w") as f:
            f.write(out)
        print(f"Wrote {args.out}")
    else:
        print(out)


if __name__ == "__main__":
    main()
