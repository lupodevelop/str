#!/usr/bin/env python3
"""
Generator for Unicode display width tables.

Downloads EastAsianWidth.txt and UnicodeData.txt from Unicode 15.1.0 and produces
`src/str/internal_display_width.gleam` with efficient lookup.

Width mapping:
 - EastAsianWidth 'W' (Wide) or 'F' (Fullwidth) -> width 2
 - 'A' (Ambiguous) -> configurable (1 or 2 based on context)
 - Combining marks (General Category Mn/Me) -> width 0
 - Everything else -> width 1

Usage:
  python3 scripts/generate_display_width_tables.py
"""

import argparse
import sys
import urllib.request
from pathlib import Path
import re

ROOT = Path(__file__).resolve().parents[1]
OUT_PATH = ROOT / "src" / "str" / "internal_display_width.gleam"

EAW_URL = "https://www.unicode.org/Public/15.1.0/ucd/EastAsianWidth.txt"
UNICODEDATA_URL = "https://www.unicode.org/Public/15.1.0/ucd/UnicodeData.txt"

RANGE_RE = re.compile(r"^([0-9A-F]+)(?:\.\.([0-9A-F]+))?\s*;\s*(\w+)")


def fetch(url: str) -> str:
    print(f"Downloading {url}...")
    with urllib.request.urlopen(url) as r:
        return r.read().decode("utf-8")


def parse_eaw(text: str):
    """Return list of (start_int, end_int, category)"""
    out = []
    for line in text.splitlines():
        line = line.split("#", 1)[0].strip()
        if not line:
            continue
        m = RANGE_RE.match(line)
        if not m:
            continue
        a = int(m.group(1), 16)
        b = int(m.group(2), 16) if m.group(2) else a
        cat = m.group(3)
        out.append((a, b, cat))
    return out


def parse_unicode_data(text: str):
    """Return set of codepoints whose General Category is Mn or Me (combining marks)."""
    marks = set()
    for line in text.splitlines():
        if not line or line.startswith("#"):
            continue
        fields = line.split(";")
        if len(fields) < 3:
            continue
        cp_hex = fields[0]
        gc = fields[2]
        cp = int(cp_hex, 16)
        if gc in ("Mn", "Me"):
            marks.add(cp)
    return marks


def compact_ranges(ranges):
    """Merge adjacent/overlapping ranges with same width."""
    if not ranges:
        return []
    ranges = sorted(ranges)
    out = []
    cur_s, cur_e, cur_w = ranges[0]
    for s, e, w in ranges[1:]:
        if w == cur_w and s <= cur_e + 1:
            cur_e = max(cur_e, e)
        else:
            out.append((cur_s, cur_e, cur_w))
            cur_s, cur_e, cur_w = s, e, w
    out.append((cur_s, cur_e, cur_w))
    return out


def compact_codepoints_to_ranges(codepoints):
    """Convert set of codepoints to list of (start, end) ranges."""
    if not codepoints:
        return []
    cps = sorted(codepoints)
    ranges = []
    start = end = cps[0]
    for cp in cps[1:]:
        if cp == end + 1:
            end = cp
        else:
            ranges.append((start, end))
            start = end = cp
    ranges.append((start, end))
    return ranges


def generate_gleam(out_path: Path, eaw_ranges, combining_set):
    """Generate clean Gleam module with list-based lookup."""
    
    # Convert EAW categories to width values
    # Width encoding: 0 = combining, 1 = narrow, 2 = wide, 3 = ambiguous (resolved at runtime)
    width_ranges = []
    for s, e, cat in eaw_ranges:
        if cat in ("W", "F"):
            width_ranges.append((s, e, 2))
        elif cat == "A":
            width_ranges.append((s, e, 3))  # 3 = ambiguous
        else:
            width_ranges.append((s, e, 1))
    
    # Compact ranges
    width_ranges = compact_ranges(width_ranges)
    
    # Compact combining marks
    combining_ranges = compact_codepoints_to_ranges(combining_set)
    
    # Filter to keep only non-default ranges (wide=2 and ambiguous=3)
    # Default is 1 for narrow, so we only store exceptions
    special_ranges = [(s, e, w) for s, e, w in width_ranges if w in (2, 3)]
    
    lines = []
    lines.append('//// Auto-generated by scripts/generate_display_width_tables.py')
    lines.append('//// Unicode 15.1.0 EastAsianWidth + combining marks for display width')
    lines.append('//// ')
    lines.append(f'//// Stats: {len(special_ranges)} width ranges, {len(combining_ranges)} combining ranges')
    lines.append('')
    lines.append('import gleam/list')
    lines.append('')
    
    # Type for width ranges: #(start, end, width)
    # Width: 2 = wide, 3 = ambiguous
    lines.append('/// Width range: #(start_codepoint, end_codepoint, width)')
    lines.append('/// Width values: 2 = wide/fullwidth, 3 = ambiguous')
    lines.append('type WidthRange =')
    lines.append('  #(Int, Int, Int)')
    lines.append('')
    
    # Generate combining ranges as a const list
    lines.append('/// Combining mark ranges (width 0)')
    lines.append('const combining_ranges: List(#(Int, Int)) = [')
    for i, (s, e) in enumerate(combining_ranges):
        comma = ',' if i < len(combining_ranges) - 1 else ''
        lines.append(f'  #({s}, {e}){comma}')
    lines.append(']')
    lines.append('')
    
    # Generate width ranges as a const list (sorted by start for binary search)
    lines.append('/// Width ranges for wide (2) and ambiguous (3) characters')
    lines.append('const width_ranges: List(WidthRange) = [')
    for i, (s, e, w) in enumerate(special_ranges):
        comma = ',' if i < len(special_ranges) - 1 else ''
        lines.append(f'  #({s}, {e}, {w}){comma}')
    lines.append(']')
    lines.append('')
    
    # Helper function to check if codepoint is in a range list
    lines.append('/// Check if codepoint falls within any range in the list')
    lines.append('fn in_ranges(cp: Int, ranges: List(#(Int, Int))) -> Bool {')
    lines.append('  list.any(ranges, fn(range) {')
    lines.append('    let #(start, end) = range')
    lines.append('    cp >= start && cp <= end')
    lines.append('  })')
    lines.append('}')
    lines.append('')
    
    # Helper function to find width from range list
    lines.append('/// Find width for codepoint in width ranges, returns 0 if not found')
    lines.append('fn find_width(cp: Int, ranges: List(WidthRange)) -> Int {')
    lines.append('  case list.find(ranges, fn(range) {')
    lines.append('    let #(start, end, _width) = range')
    lines.append('    cp >= start && cp <= end')
    lines.append('  }) {')
    lines.append('    Ok(#(_, _, width)) -> width')
    lines.append('    Error(_) -> 0')
    lines.append('  }')
    lines.append('}')
    lines.append('')
    
    # Main public function
    lines.append('/// Get the display width of a single codepoint.')
    lines.append('/// ')
    lines.append('/// - `cp`: Unicode codepoint value')
    lines.append('/// - `ambiguous_as`: Width to use for ambiguous characters (typically 1 or 2)')
    lines.append('/// ')
    lines.append('/// Returns: 0 for combining marks, 2 for wide/fullwidth, 1 for narrow')
    lines.append('pub fn codepoint_width(cp: Int, ambiguous_as: Int) -> Int {')
    lines.append('  // Check combining marks first (width 0)')
    lines.append('  case in_ranges(cp, combining_ranges) {')
    lines.append('    True -> 0')
    lines.append('    False -> {')
    lines.append('      // Check wide/ambiguous ranges')
    lines.append('      case find_width(cp, width_ranges) {')
    lines.append('        2 -> 2  // Wide/fullwidth')
    lines.append('        3 -> ambiguous_as  // Ambiguous - use provided width')
    lines.append('        _ -> 1  // Default: narrow')
    lines.append('      }')
    lines.append('    }')
    lines.append('  }')
    lines.append('}')

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text('\n'.join(lines), encoding='utf-8')
    print(f'Wrote {out_path}')
    print(f'  - {len(special_ranges)} width ranges (wide + ambiguous)')
    print(f'  - {len(combining_ranges)} combining mark ranges')


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--out', default=str(OUT_PATH))
    args = parser.parse_args()

    try:
        eaw = fetch(EAW_URL)
        ud = fetch(UNICODEDATA_URL)
    except Exception as e:
        print('Error fetching UCD files:', e)
        sys.exit(1)

    eaw_ranges = parse_eaw(eaw)
    combining = parse_unicode_data(ud)

    print(f'Parsed {len(eaw_ranges)} EastAsianWidth entries; {len(combining)} combining codepoints')

    generate_gleam(Path(args.out), eaw_ranges, combining)


if __name__ == '__main__':
    main()
