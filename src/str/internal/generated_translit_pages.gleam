// Generated by scripts/generate_bitarray_tables.py
// Module: generated_translit_table

import gleam/list
import gleam/string

pub const translit_pages_page_offsets: List(Int) = [ 0, 62, 132 ]

pub const translit_pages_page_bitlists: List(List(Int)) = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

pub const translit_pages_data_pool: List(String) = [
  "A",
  "A",
  "A",
  "A",
  "A",
  "A",
  "AE",
  "C",
  "E",
  "E",
  "E",
  "E",
  "I",
  "I",
  "I",
  "I",
  "D",
  "N",
  "O",
  "O",
  "O",
  "O",
  "O",
  "O",
  "U",
  "U",
  "U",
  "U",
  "Y",
  "TH",
  "ss",
  "a",
  "a",
  "a",
  "a",
  "a",
  "a",
  "ae",
  "c",
  "e",
  "e",
  "e",
  "e",
  "i",
  "i",
  "i",
  "i",
  "d",
  "n",
  "o",
  "o",
  "o",
  "o",
  "o",
  "o",
  "u",
  "u",
  "u",
  "u",
  "y",
  "th",
  "y",
  "A",
  "a",
  "A",
  "a",
  "A",
  "a",
  "C",
  "c",
  "C",
  "c",
  "D",
  "d",
  "D",
  "d",
  "E",
  "e",
  "E",
  "e",
  "E",
  "e",
  "E",
  "e",
  "G",
  "g",
  "G",
  "g",
  "I",
  "i",
  "I",
  "i",
  "K",
  "k",
  "L",
  "l",
  "L",
  "l",
  "N",
  "n",
  "N",
  "n",
  "O",
  "o",
  "OE",
  "oe",
  "R",
  "r",
  "R",
  "r",
  "R",
  "r",
  "S",
  "s",
  "S",
  "s",
  "S",
  "s",
  "T",
  "t",
  "T",
  "t",
  "U",
  "u",
  "U",
  "u",
  "U",
  "u",
  "Z",
  "z",
  "Z",
  "z",
  "S",
  "s",
  "T",
  "t"
]

fn get_at(xs: List(a), idx: Int) -> Result(a, Nil) {
  case list.drop(xs, idx) {
    [h, ..] -> Ok(h)
    _ -> Error(Nil)
  }
}

pub fn translit_pages_lookup_by_codepoint(cp: Int) -> Result(String, Nil) {
  let page = cp / 256
  case get_at(translit_pages_page_offsets, page) {
    Ok(offset) ->
      case offset == -1 {
        True -> Error(Nil)
        False -> {
          let idx = cp % 256
          let page_bits = case get_at(translit_pages_page_bitlists, page) { Ok(b) -> b Error(_) -> [] }
          let bit = case get_at(page_bits, idx) { Ok(v) -> v Error(_) -> 0 }
          case bit == 0 {
            True -> Error(Nil)
            False -> {
              let mask = list.take(page_bits, idx)
              let rank = list.fold(mask, 0, fn(acc, b) { acc + b })
              let val = case get_at(translit_pages_data_pool, offset + rank) { Ok(v) -> v Error(_) -> "" }
              Ok(val)
            }
          }
        }
      }
    Error(_) -> Error(Nil)
  }
}

pub fn translit_pages_lookup_by_grapheme(s: String) -> Result(String, Nil) {
  case string.to_utf_codepoints(s) {
    [cp] -> translit_pages_lookup_by_codepoint(string.utf_codepoint_to_int(cp))
    _ -> Error(Nil)
  }
}
