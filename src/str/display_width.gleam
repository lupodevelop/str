//// Display width utilities (stable implementation).
//// Uses `src/str/internal_display_width.gleam` generated by the generator script.

import gleam/list
import gleam/string
import str/internal_display_width

/// Heuristic detection for emoji-like clusters.
fn cluster_has_emoji(cluster: String) -> Bool {
  let cps = string.to_utf_codepoints(cluster)
  list.any(cps, fn(cp) {
    let code = string.utf_codepoint_to_int(cp)
    // ZWJ, variation selector, keycap, skin tones, regional indicators, tags, pictographic
    code == 0x200D
      || code == 0xFE0F
      || code == 0x20E3
      || code >= 0x1F3FB && code <= 0x1F3FF
      || code >= 0x1F1E6 && code <= 0x1F1FF
      || code >= 0xE0020 && code <= 0xE007F
      || code >= 0x1F000 && code <= 0x1FAFF
  })
}

/// Returns the display width (columns) of a grapheme cluster.
fn cluster_display_width(cluster: String, ambiguous_as: Int) -> Int {
  // If cluster looks like emoji use width 2 to avoid oversized sums.
  case cluster_has_emoji(cluster) {
    True -> 2
    False -> {
      string.to_utf_codepoints(cluster)
      |> list.map(fn(cp) {
        let code = string.utf_codepoint_to_int(cp)
        internal_display_width.codepoint_width(code, ambiguous_as)
      })
      |> list.fold(0, fn(acc, v) { acc + v })
    }
  }
}

/// Compute display width of a string using grapheme clusters.
pub fn display_width(text: String, ambiguous_as: Int) -> Int {
  text
  |> string.to_graphemes
  |> list.fold(0, fn(acc, g) { acc + cluster_display_width(g, ambiguous_as) })
}

/// Truncate a string to a maximum *display* width (columns), appending `suffix` when truncated.
/// This function preserves grapheme clusters (no ZWJ/emoji splitting) because it iterates clusters.
pub fn truncate_display(
  text: String,
  max_width: Int,
  suffix: String,
  ambiguous_as: Int,
) -> String {
  case max_width <= 0 {
    True -> ""
    False -> {
      let clusters = string.to_graphemes(text)
      let total_width = display_width(text, ambiguous_as)
      let suffix_w = display_width(suffix, ambiguous_as)

      case total_width <= max_width {
        True -> text
        False -> {
          let available = max_width - suffix_w
          case available <= 0 {
            True ->
              string.to_graphemes(suffix)
              |> list.take(max_width)
              |> string.concat
            False -> {
              // Accumulate clusters until exceeding available
              let #(kept, _) =
                list.fold(clusters, #([], 0), fn(acc, cluster) {
                  let #(acc_clusters, acc_w) = acc
                  let w = cluster_display_width(cluster, ambiguous_as)
                  case acc_w + w <= available {
                    True -> #([cluster, ..acc_clusters], acc_w + w)
                    False -> #(acc_clusters, acc_w)
                  }
                })

              // kept is reversed because we consed; reverse and concat
              list.reverse(kept) |> list.fold("", fn(acc, s) { acc <> s })
              <> suffix
            }
          }
        }
      }
    }
  }
}

/// Pad to the target display width (left/right/center). `side` is "left" | "right" | "center".
pub fn pad_display(
  text: String,
  width: Int,
  side: String,
  pad: String,
  ambiguous_as: Int,
) -> String {
  let w = display_width(text, ambiguous_as)
  case w >= width {
    True -> text
    False -> {
      let need = width - w
      case side {
        "left" -> repeat_pad(pad, need) <> text
        "right" -> text <> repeat_pad(pad, need)
        "center" -> {
          let left = need / 2
          let right = need - left
          repeat_pad(pad, left) <> text <> repeat_pad(pad, right)
        }
        _ -> text
      }
    }
  }
}

fn repeat_pad(p: String, n: Int) -> String {
  case n <= 0 {
    True -> ""
    False -> list.fold(list.range(1, n), "", fn(acc, _) { acc <> p })
  }
}
